//
// OrderRefundAdd.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct OrderRefundAdd: Codable, JSONEncodable, Hashable {

    /** Defines the order for which the refund will be created. */
    public var orderId: String?
    /** Defines items in the order that will be refunded */
    public var items: [OrderRefundAddItemsInner]?
    /** Defines order refund amount. */
    public var totalPrice: Double?
    /** Defines refund shipping amount. */
    public var shippingPrice: Double?
    /** Specifies refund's fee price */
    public var feePrice: Double?
    /** Refund reason, or some else message which assigned to refund. */
    public var message: String?
    /** Boolean, whether or not to add the line items back to the store inventory. */
    public var itemRestock: Bool? = false
    /** Send notifications to customer after refund was created */
    public var sendNotifications: Bool? = false
    /** Specifies an order creation date in format Y-m-d H:i:s */
    public var date: String?
    /** Indicates whether refund type is online */
    public var isOnline: Bool? = false
    /** A unique identifier associated with a specific request. Repeated requests with the same <strong>idempotency_key</strong> return a cached response without re-executing the business logic. <strong>Please note that the cache lifetime is 15 minutes.</strong> */
    public var idempotencyKey: String?

    public init(orderId: String? = nil, items: [OrderRefundAddItemsInner]? = nil, totalPrice: Double? = nil, shippingPrice: Double? = nil, feePrice: Double? = nil, message: String? = nil, itemRestock: Bool? = false, sendNotifications: Bool? = false, date: String? = nil, isOnline: Bool? = false, idempotencyKey: String? = nil) {
        self.orderId = orderId
        self.items = items
        self.totalPrice = totalPrice
        self.shippingPrice = shippingPrice
        self.feePrice = feePrice
        self.message = message
        self.itemRestock = itemRestock
        self.sendNotifications = sendNotifications
        self.date = date
        self.isOnline = isOnline
        self.idempotencyKey = idempotencyKey
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case orderId = "order_id"
        case items
        case totalPrice = "total_price"
        case shippingPrice = "shipping_price"
        case feePrice = "fee_price"
        case message
        case itemRestock = "item_restock"
        case sendNotifications = "send_notifications"
        case date
        case isOnline = "is_online"
        case idempotencyKey = "idempotency_key"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(orderId, forKey: .orderId)
        try container.encodeIfPresent(items, forKey: .items)
        try container.encodeIfPresent(totalPrice, forKey: .totalPrice)
        try container.encodeIfPresent(shippingPrice, forKey: .shippingPrice)
        try container.encodeIfPresent(feePrice, forKey: .feePrice)
        try container.encodeIfPresent(message, forKey: .message)
        try container.encodeIfPresent(itemRestock, forKey: .itemRestock)
        try container.encodeIfPresent(sendNotifications, forKey: .sendNotifications)
        try container.encodeIfPresent(date, forKey: .date)
        try container.encodeIfPresent(isOnline, forKey: .isOnline)
        try container.encodeIfPresent(idempotencyKey, forKey: .idempotencyKey)
    }
}

